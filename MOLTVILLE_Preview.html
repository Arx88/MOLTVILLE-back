<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MOLTVILLE</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #1a1a2e; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
  #game-container { width: 100vw; height: 100vh; }
  canvas { display: block; }

  /* HUD */
  #hud { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
  #top-bar {
    position: absolute; top: 16px; left: 50%; transform: translateX(-50%);
    background: rgba(15,15,30,0.85); border: 1px solid rgba(100,140,255,0.3);
    border-radius: 12px; padding: 8px 24px; display: flex; align-items: center; gap: 20px;
    backdrop-filter: blur(8px);
  }
  #top-bar .city-name { color: #a8c4ff; font-size: 18px; font-weight: 700; letter-spacing: 3px; text-transform: uppercase; }
  #top-bar .time-display { color: #7faaee; font-size: 13px; }
  #top-bar .agent-count { color: #6bcb77; font-size: 13px; }

  #chat-log {
    position: absolute; bottom: 80px; left: 20px; width: 320px; max-height: 200px;
    background: rgba(15,15,30,0.8); border: 1px solid rgba(100,140,255,0.2);
    border-radius: 12px; padding: 12px; overflow-y: auto; backdrop-filter: blur(6px);
  }
  .chat-msg { color: #ccc; font-size: 12px; margin-bottom: 4px; line-height: 1.4; }
  .chat-msg .name { color: #a8c4ff; font-weight: 600; }
  .chat-msg .time { color: #555; font-size: 10px; }

  #minimap-container {
    position: absolute; bottom: 20px; right: 20px;
    background: rgba(15,15,30,0.85); border: 1px solid rgba(100,140,255,0.3);
    border-radius: 10px; padding: 8px; backdrop-filter: blur(6px);
  }
  #minimap { border-radius: 6px; }

  #agents-panel {
    position: absolute; top: 60px; right: 20px; width: 160px;
    background: rgba(15,15,30,0.8); border: 1px solid rgba(100,140,255,0.2);
    border-radius: 12px; padding: 10px; backdrop-filter: blur(6px);
  }
  .agent-item { display: flex; align-items: center; gap: 8px; padding: 4px 0; }
  .agent-dot { width: 8px; height: 8px; border-radius: 50%; }
  .agent-name-hud { color: #ccc; font-size: 12px; }
</style>
</head>
<body>
<div id="game-container"></div>
<div id="hud">
  <div id="top-bar">
    <span class="city-name">üèôÔ∏è Moltville</span>
    <span class="time-display" id="time-display">‚òÄÔ∏è 10:00 AM</span>
    <span class="agent-count" id="agent-count">üë• 0 Citizens</span>
  </div>
  <div id="chat-log"></div>
  <div id="agents-panel"></div>
  <div id="minimap-container">
    <canvas id="minimap" width="140" height="140"></canvas>
  </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.60.0/phaser.min.js"></script>
<script>
// ============================================================
// MOLTVILLE ‚Äî WORLD DATA
// ============================================================
const TILE = 32;
const WORLD_W = 64;
const WORLD_H = 64;
const ISO_W = TILE;
const ISO_H = TILE / 2;

// Tile types
const T = { GRASS:0, ROAD:1, WATER:2, SAND:3, STONE:4, DIRT:5, PATH:6, FLOWER:7 };

// Building definitions ‚Äî richer and more varied
const BUILDINGS = [
  // ‚îÄ‚îÄ Caf√©s & Social ‚îÄ‚îÄ
  { id:'cafe1', name:'Hobbs Caf√©', type:'cafe', x:14, y:8,  w:5, h:4, color:'#c0392b', roof:'#e74c3c', accent:'#f39c12', stories:1 },
  { id:'cafe2', name:'Corner Bistro', type:'cafe', x:42, y:18, w:4, h:3, color:'#8e6b3e', roof:'#a67c52', accent:'#e67e22', stories:1 },

  // ‚îÄ‚îÄ Library & Culture ‚îÄ‚îÄ
  { id:'library', name:'City Library', type:'library', x:24, y:6,  w:6, h:5, color:'#5b4a8a', roof:'#7d6ba0', accent:'#9b8ec4', stories:2 },
  { id:'gallery', name:'Art Gallery', type:'gallery', x:50, y:8,  w:4, h:4, color:'#6c5b73', roof:'#8a7490', accent:'#d4a84b', stories:2 },

  // ‚îÄ‚îÄ Shops & Commerce ‚îÄ‚îÄ
  { id:'shop1', name:'General Store', type:'shop', x:30, y:14, w:4, h:3, color:'#2980b9', roof:'#3498db', accent:'#f1c40f', stories:1 },
  { id:'shop2', name:'Bookshop', type:'shop', x:8,  y:22, w:3, h:3, color:'#27ae60', roof:'#2ecc71', accent:'#e74c3c', stories:1 },
  { id:'market', name:'Market Square', type:'market', x:36, y:28, w:6, h:5, color:'#16a085', roof:'#1abc9c', accent:'#f39c12', stories:1 },

  // ‚îÄ‚îÄ Residences (varied) ‚îÄ‚îÄ
  { id:'house1', name:'Maple House', type:'house', x:6,  y:6,  w:3, h:2, color:'#e67e22', roof:'#d35400', accent:'#f39c12', stories:1 },
  { id:'house2', name:'Oak Cottage', type:'house', x:10, y:14, w:2, h:2, color:'#9b59b6', roof:'#8e44ad', accent:'#f39c12', stories:1 },
  { id:'house3', name:'Pine Villa', type:'house', x:4,  y:28, w:3, h:3, color:'#3498db', roof:'#2980b9', accent:'#ecf0f1', stories:1 },
  { id:'house4', name:'Cedar Home', type:'house', x:48, y:24, w:3, h:2, color:'#e74c3c', roof:'#c0392b', accent:'#f1c40f', stories:1 },
  { id:'house5', name:'Birch Flat', type:'house', x:54, y:32, w:2, h:3, color:'#1abc9c', roof:'#16a085', accent:'#e67e22', stories:1 },
  { id:'house6', name:'Elm Residence', type:'house', x:18, y:36, w:3, h:2, color:'#e67e22', roof:'#d35400', accent:'#ecf0f1', stories:1 },

  // ‚îÄ‚îÄ Tall Buildings (city feel) ‚îÄ‚îÄ
  { id:'tower1', name:'City Hall', type:'civic', x:28, y:22, w:4, h:4, color:'#34495e', roof:'#2c3e50', accent:'#3498db', stories:3 },
  { id:'tower2', name:'Bell Tower', type:'tower', x:20, y:24, w:3, h:3, color:'#95a5a6', roof:'#7f8c8d', accent:'#f39c12', stories:4 },
  { id:'apts', name:'Sunrise Apartments', type:'apartment', x:44, y:34, w:5, h:4, color:'#2c3e50', roof:'#34495e', accent:'#3498db', stories:3 },

  // ‚îÄ‚îÄ Parks & Public ‚îÄ‚îÄ
  { id:'fountain', name:'Central Plaza', type:'plaza', x:16, y:18, w:6, h:6, color:'#95a5a6', roof:'#bdc3c7', accent:'#3498db', stories:0 },
  { id:'park2', name:'Sunset Garden', type:'garden', x:40, y:42, w:7, h:6, color:'#27ae60', roof:'#2ecc71', accent:'#f39c12', stories:0 },

  // ‚îÄ‚îÄ Special ‚îÄ‚îÄ
  { id:'inn', name:'Travelers Inn', type:'inn', x:52, y:42, w:4, h:3, color:'#a04000', roof:'#c0392b', accent:'#f39c12', stories:2 },
  { id:'church', name:'Chapel', type:'chapel', x:8,  y:42, w:3, h:4, color:'#ecf0f1', roof:'#bdc3c7', accent:'#f39c12', stories:2 },
];

// Road network definition (tile coordinates that are roads)
function generateTileMap() {
  const map = [];
  for (let y = 0; y < WORLD_H; y++) {
    map[y] = [];
    for (let x = 0; x < WORLD_W; x++) {
      // Base: mostly grass
      let t = T.GRASS;

      // Water: bottom-right corner lake + small stream
      if (x > 52 && y > 52) t = T.WATER;
      if (x > 56 && y > 46) t = T.WATER;
      // Small river running diagonally
      if ((x >= 38 && x <= 40 && y >= 44 && y <= 64)) t = T.WATER;
      if ((x >= 40 && x <= 42 && y >= 50 && y <= 60)) t = T.WATER;

      // Sand around water
      if ((x === 52 && y > 52) || (x > 52 && y === 52)) t = T.SAND;
      if (x === 37 && y >= 44 && y <= 55) t = T.SAND;
      if (x === 41 && y >= 44 && y <= 55) t = T.SAND;

      // Main roads ‚Äî thick arterials
      // Horizontal main road y=12
      if (y >= 11 && y <= 13 && x >= 2 && x <= 62) t = T.ROAD;
      // Horizontal main road y=26
      if (y >= 25 && y <= 27 && x >= 2 && x <= 60) t = T.ROAD;
      // Horizontal road y=40
      if (y >= 39 && y <= 41 && x >= 2 && x <= 55) t = T.ROAD;
      // Vertical main road x=12
      if (x >= 11 && x <= 13 && y >= 2 && y <= 55) t = T.ROAD;
      // Vertical main road x=26
      if (x >= 25 && x <= 27 && y >= 2 && y <= 55) t = T.ROAD;
      // Vertical main road x=38
      if (x >= 37 && x <= 39 && y >= 2 && y <= 42) t = T.ROAD;
      // Vertical main road x=50
      if (x >= 49 && x <= 51 && y >= 2 && y <= 50) t = T.ROAD;

      // Smaller paths connecting areas
      if (y === 20 && x >= 13 && x <= 25) t = T.PATH;
      if (y === 33 && x >= 13 && x <= 25) t = T.PATH;
      if (x === 20 && y >= 13 && y <= 25) t = T.PATH;
      if (x === 32 && y >= 13 && y <= 25) t = T.PATH;
      if (x === 45 && y >= 13 && y <= 25) t = T.PATH;
      if (y === 48 && x >= 2  && x <= 37) t = T.PATH;
      if (x === 8  && y >= 27 && y <= 39) t = T.PATH;
      if (x === 33 && y >= 27 && y <= 39) t = T.PATH;
      if (x === 46 && y >= 27 && y <= 39) t = T.PATH;

      map[y][x] = t;
    }
  }
  return map;
}

// Decorative objects: benches, lampposts, trees, flower patches, fountains
function generateDecorations() {
  const decs = [];
  const rng = (seed) => { let s=seed; return ()=>{ s=s*16807%2147483647; return (s-1)/2147483646; }; };
  const r = rng(42);

  // Trees scattered on grass areas
  const treePositions = [
    [3,3],[5,9],[7,4],[9,3],[15,4],[17,3],[19,4],[22,3],[31,3],[33,5],[35,3],[41,3],[43,5],[45,3],[47,5],
    [3,15],[5,17],[3,22],[5,24],[3,30],[5,32],[3,35],[5,38],[3,44],[5,46],[7,50],[9,48],
    [15,15],[17,17],[19,15],[22,32],[24,34],[18,42],[20,44],[22,46],[24,48],
    [29,5],[31,7],[33,9],[35,5],[29,30],[31,32],[33,34],[35,36],
    [41,5],[43,7],[41,15],[43,17],[45,5],[47,15],[49,5],[51,5],[53,5],
    [41,30],[43,32],[45,34],[47,30],[49,32],[51,34],[53,30],
    [42,44],[44,46],[46,48],[48,44],[50,42],[52,40],[54,38],
    [8,52],[10,54],[12,50],[14,52],[16,54],[18,50],[20,52],[22,54],[24,50],
    [26,50],[28,52],[30,54],[32,50],[34,52],[36,50],
    [2,55],[4,57],[6,55],[8,57],[10,58],[12,56],[14,58],[16,56],
    [44,52],[46,54],[48,50],[50,48],[52,46],[54,44],[56,42],
    [3,42],[5,44],[7,46],[9,44],[11,42],[13,44],
    [27,42],[29,44],[31,42],[33,44],[35,42],[37,40],
    [55,10],[57,12],[55,16],[57,18],[55,22],[57,24],[55,28],[57,30],
    [42,8],[44,10],[46,12],[48,8],[52,12],[54,10],[56,8],
    [59,5],[61,3],[61,8],[59,14],[61,16],[59,22],[61,26],[59,34],[61,38],
    [27,46],[29,48],[31,50],[33,48],[35,46],
  ];
  treePositions.forEach((p,i) => {
    decs.push({ type:'tree', x:p[0], y:p[1], variant: i%3 });
  });

  // Lampposts along roads
  for (let x = 3; x < 62; x += 4) {
    if ([11,25,39].some(ry => true)) {
      decs.push({ type:'lamp', x:x, y:10 });
      decs.push({ type:'lamp', x:x, y:14 });
      decs.push({ type:'lamp', x:x, y:24 });
      decs.push({ type:'lamp', x:x, y:28 });
      decs.push({ type:'lamp', x:x, y:38 });
      decs.push({ type:'lamp', x:x, y:42 });
    }
  }
  for (let y = 3; y < 55; y += 4) {
    [10,14,24,28,36,40,48,52].forEach(rx => {
      decs.push({ type:'lamp', x:rx, y:y });
    });
  }

  // Benches near plazas and parks
  const benchSpots = [
    [15,17],[21,17],[15,24],[21,24], // near plaza
    [27,20],[29,20],[27,24],[29,24], // city hall area
    [39,29],[43,29],[39,33],[43,33], // market area
    [41,43],[45,43],[41,47],[45,47], // sunset garden
    [8,40],[10,40],[7,44],[11,44],   // near chapel
  ];
  benchSpots.forEach((p,i) => decs.push({ type:'bench', x:p[0], y:p[1], variant:i%2 }));

  // Flower patches
  const flowerSpots = [
    [16,19],[17,19],[18,19],[19,19],[20,19],[21,19], // plaza edges
    [16,23],[17,23],[18,23],[19,23],[20,23],[21,23],
    [41,43],[42,43],[43,43],[44,43],[45,43],[46,43], // garden
    [41,47],[42,47],[43,47],[44,47],[45,47],[46,47],
    [9,43],[10,43],[11,43],[12,43],
    [5,5],[6,5],[7,5],
    [48,25],[49,25],[50,25],
  ];
  flowerSpots.forEach((p,i) => decs.push({ type:'flower', x:p[0], y:p[1], color: ['#e74c3c','#9b59b6','#f39c12','#e67e22'][i%4] }));

  return decs;
}

// ============================================================
// DEMO AGENTS (simulate moltbots)
// ============================================================
const AGENT_COLORS = ['#e74c3c','#3498db','#2ecc71','#9b59b6','#f39c12','#1abc9c','#e67e22','#e84393'];
const AGENT_NAMES = ['Alice','Bob','Clara','Diego','Eva','Frank','Grace','Hugo'];
const AGENT_TARGETS = {}; // id -> {x,y}

function createDemoAgents() {
  return AGENT_NAMES.map((name, i) => ({
    id: i,
    name,
    color: AGENT_COLORS[i],
    x: 12 + (i % 4) * 3,
    y: 12 + Math.floor(i / 4) * 3,
    tx: 12 + (i % 4) * 3, // target
    ty: 12 + Math.floor(i / 4) * 3,
    facing: 'down',
    progress: 1, // 1 = at position, 0 = start moving
    walkCycle: 0,
    state: 'idle', // idle, walking, talking
    talkTimer: 0,
    idleTimer: Math.random() * 120,
  }));
}

// ============================================================
// ISOMETRIC HELPERS
// ============================================================
function toIso(tx, ty) {
  return {
    x: (tx - ty) * (ISO_W / 2),
    y: (tx + ty) * (ISO_H / 2)
  };
}

// ============================================================
// PHASER SCENE
// ============================================================
class MoltivilleScene extends Phaser.Scene {
  constructor() {
    super({ key: 'MoltvilleScene' });
    this.tileMap = [];
    this.decorations = [];
    this.agents = [];
    this.chatLog = [];
    this.gameTime = 600; // minutes from midnight (10:00)
    this.clouds = [];
  }

  preload() {
    // We draw everything procedurally
  }

  create() {
    this.tileMap = generateTileMap();
    this.decorations = generateDecorations();
    this.agents = createDemoAgents();

    // Sky gradient background
    const skyGfx = this.add.graphics();
    skyGfx.fillGradientStyle(0x1a2744, 0x1a2744, 0x2d4a7a, 0x2d4a7a, 1);
    skyGfx.fillRect(0, 0, this.sys.game.config.width, this.sys.game.config.height);
    skyGfx.setDepth(-100);

    // World container
    this.worldContainer = this.add.container(0, 0);
    this.worldContainer.setDepth(0);

    // Draw base tiles layer
    this.drawTiles();

    // Draw decorations bottom layer (flowers, benches)
    this.drawDecorationsBottom();

    // Draw buildings
    this.drawBuildings();

    // Agent graphics will be drawn each frame
    this.agentGraphics = this.add.graphics();
    this.agentGraphics.setDepth(500);

    // Speech bubble graphics
    this.speechGraphics = this.add.graphics();
    this.speechGraphics.setDepth(600);

    // Draw decorations top layer (trees, lampposts) after buildings
    this.drawDecorationsTop();

    // Clouds
    this.createClouds();

    // Minimap
    this.setupMinimap();

    // Camera
    const centerAgent = this.agents[0];
    const cPos = toIso(centerAgent.x, centerAgent.y);
    this.cameras.main.centerOn(
      cPos.x + this.sys.game.config.width / 2,
      cPos.y + this.sys.game.config.height / 2 - 40
    );

    // Input: drag to pan
    this.input.on('pointerdown', (p) => { this._dragStart = { x: p.x, y: p.y, cx: this.cameras.main.scrollX, cy: this.cameras.main.scrollY }; });
    this.input.on('pointermove', (p) => {
      if (this._dragStart) {
        this.cameras.main.scrollX = this._dragStart.cx - (p.x - this._dragStart.x);
        this.cameras.main.scrollY = this._dragStart.cy - (p.y - this._dragStart.y);
      }
    });
    this.input.on('pointerup', () => { this._dragStart = null; });
    // Zoom
    this.input.on('wheel', (p, dx, dy) => {
      // Simple: don't zoom for now, just allow scrolling nuance
    });
  }

  drawTiles() {
    const gfx = this.add.graphics();
    gfx.setDepth(-50);

    for (let y = 0; y < WORLD_H; y++) {
      for (let x = 0; x < WORLD_W; x++) {
        const t = this.tileMap[y][x];
        const pos = toIso(x, y);
        const px = pos.x + this.sys.game.config.width / 2;
        const py = pos.y + this.sys.game.config.height / 2;

        this.drawTile(gfx, px, py, t, x, y);
      }
    }
  }

  drawTile(gfx, px, py, type, tx, ty) {
    const w = ISO_W;
    const h = ISO_H;
    // Diamond points: top, right, bottom, left
    const pts = [
      { x: px, y: py - h/2 },         // top
      { x: px + w/2, y: py },          // right
      { x: px, y: py + h/2 },          // bottom
      { x: px - w/2, y: py },          // left
    ];

    let baseColor, edgeColor, detailColor;
    switch(type) {
      case T.GRASS:
        // Slight variation based on position
        const shade = ((tx*7 + ty*13) % 5);
        baseColor = [0x3d8b41, 0x3a8540, 0x40913f, 0x3c8d42, 0x3e8e40][shade];
        edgeColor = 0x2d6b30;
        break;
      case T.ROAD:
        baseColor = 0x4a4a5a;
        edgeColor = 0x3a3a4a;
        detailColor = 0x5a5a6a;
        break;
      case T.PATH:
        baseColor = 0xc4a882;
        edgeColor = 0xb09570;
        break;
      case T.WATER:
        baseColor = 0x2980b9;
        edgeColor = 0x1a6a9e;
        break;
      case T.SAND:
        baseColor = 0xf0d9a0;
        edgeColor = 0xdcc680;
        break;
      case T.STONE:
        baseColor = 0x7f8c8d;
        edgeColor = 0x6b7b7d;
        break;
      default:
        baseColor = 0x3d8b41;
        edgeColor = 0x2d6b30;
    }

    // Fill diamond
    gfx.fillStyle(baseColor, 1);
    gfx.beginPath();
    gfx.moveTo(pts[0].x, pts[0].y);
    gfx.lineTo(pts[1].x, pts[1].y);
    gfx.lineTo(pts[2].x, pts[2].y);
    gfx.lineTo(pts[3].x, pts[3].y);
    gfx.closePath();
    gfx.fillPath();

    // Edge highlight (top-left lighter)
    gfx.fillStyle(edgeColor, 0.4);
    gfx.beginPath();
    gfx.moveTo(pts[0].x, pts[0].y);
    gfx.lineTo(pts[1].x, pts[1].y);
    gfx.lineTo(pts[2].x, pts[2].y);
    gfx.lineTo(pts[3].x, pts[3].y);
    gfx.closePath();
    // Only stroke, no fill for border
    gfx.lineStyle(1, edgeColor, 0.5);
    gfx.strokePath();

    // Road details: center line
    if (type === T.ROAD && detailColor) {
      gfx.fillStyle(detailColor, 0.3);
      gfx.beginPath();
      gfx.moveTo(pts[0].x, pts[0].y + 2);
      gfx.lineTo(pts[1].x - 2, pts[1].y);
      gfx.lineTo(pts[2].x, pts[2].y - 2);
      gfx.lineTo(pts[3].x + 2, pts[3].y);
      gfx.closePath();
      gfx.fillPath();
    }

    // Water shimmer effect
    if (type === T.WATER) {
      gfx.fillStyle(0x5dade2, 0.25);
      const shimX = (tx * 3) % 2 === 0 ? -3 : 3;
      gfx.fillRect(px + shimX - 4, py - 2, 8, 3);
    }
  }

  drawBuildings() {
    BUILDINGS.forEach(b => {
      if (b.type === 'plaza' || b.type === 'garden') {
        this.drawPlazaOrGarden(b);
      } else {
        this.drawBuilding(b);
      }
    });
  }

  drawPlazaOrGarden(b) {
    const gfx = this.add.graphics();
    // Plaza: draw stone/garden tiles over the area
    for (let dy = 0; dy < b.h; dy++) {
      for (let dx = 0; dx < b.w; dx++) {
        const tx = b.x + dx;
        const ty = b.y + dy;
        const pos = toIso(tx, ty);
        const px = pos.x + this.sys.game.config.width / 2;
        const py = pos.y + this.sys.game.config.height / 2;

        const isPlaza = b.type === 'plaza';
        this.drawTile(gfx, px, py, isPlaza ? T.STONE : T.GRASS, tx, ty);
      }
    }

    // Fountain at center of plaza
    if (b.type === 'plaza') {
      const cx = b.x + Math.floor(b.w / 2);
      const cy = b.y + Math.floor(b.h / 2);
      const pos = toIso(cx, cy);
      const px = pos.x + this.sys.game.config.width / 2;
      const py = pos.y + this.sys.game.config.height / 2;

      // Base
      gfx.fillStyle(0x95a5a6, 1);
      gfx.beginPath();
      gfx.moveTo(px, py - 8);
      gfx.lineTo(px + 12, py - 2);
      gfx.lineTo(px, py + 6);
      gfx.lineTo(px - 12, py - 2);
      gfx.closePath();
      gfx.fillPath();

      // Water basin
      gfx.fillStyle(0x2980b9, 1);
      gfx.beginPath();
      gfx.moveTo(px, py - 5);
      gfx.lineTo(px + 8, py - 1);
      gfx.lineTo(px, py + 3);
      gfx.lineTo(px - 8, py - 1);
      gfx.closePath();
      gfx.fillPath();

      // Center pillar
      gfx.fillStyle(0xbdc3c7, 1);
      gfx.fillRect(px - 2, py - 10, 4, 8);

      // Pillar top
      gfx.fillStyle(0xd5dbdb, 1);
      gfx.fillCircle(px, py - 11, 4);
    }
  }

  drawBuilding(b) {
    const gfx = this.add.graphics();
    // Get the isometric position of the building's top-left corner
    // In isometric, we draw from the "back" corner
    // The building occupies tiles from (b.x, b.y) to (b.x+b.w-1, b.y+b.h-1)
    // The "back" corner in iso is the top-left of the tile grid (min x, min y)
    // We want to draw the building footprint, then walls, then roof

    const stories = b.stories || 1;
    const storyH = 14;
    const totalH = stories * storyH;

    // Calculate the 4 corners of the building footprint in iso
    // Top-left tile: (b.x, b.y), Top-right: (b.x+b.w, b.y), Bottom-right: (b.x+b.w, b.y+b.h), Bottom-left: (b.x, b.y+b.h)
    const topLeft     = toIso(b.x,      b.y);
    const topRight    = toIso(b.x + b.w, b.y);
    const bottomRight = toIso(b.x + b.w, b.y + b.h);
    const bottomLeft  = toIso(b.x,      b.y + b.h);

    const ox = this.sys.game.config.width / 2;
    const oy = this.sys.game.config.height / 2;

    const tl = { x: topLeft.x + ox,     y: topLeft.y + oy };
    const tr = { x: topRight.x + ox,    y: topRight.y + oy };
    const br = { x: bottomRight.x + ox, y: bottomRight.y + oy };
    const bl = { x: bottomLeft.x + ox,  y: bottomLeft.y + oy };

    // Depth: use the bottom-most point for sorting (we just draw in order for simplicity)

    // === SHADOW ===
    gfx.fillStyle(0x000000, 0.15);
    gfx.beginPath();
    gfx.moveTo(tr.x + 4, tr.y + totalH + 2);
    gfx.lineTo(br.x + 4, br.y + totalH + 2);
    gfx.lineTo(br.x, br.y + totalH);
    gfx.lineTo(tr.x, tr.y + totalH);
    gfx.closePath();
    gfx.fillPath();

    // === GROUND FOOTPRINT (stone base) ===
    gfx.fillStyle(0x5d6d7e, 1);
    gfx.beginPath();
    gfx.moveTo(tl.x, tl.y);
    gfx.lineTo(tr.x, tr.y);
    gfx.lineTo(br.x, br.y);
    gfx.lineTo(bl.x, bl.y);
    gfx.closePath();
    gfx.fillPath();

    // === RIGHT WALL (facing camera - right side) ===
    // This is the wall from tr -> br, going down by totalH
    const wallRightColor = Phaser.Display.Color.ValueToColor(b.color);
    // Darken for right wall
    const rightWallColor = 0x000000 | (
      (Math.max(0, (wallRightColor.r - 40)) << 16) |
      (Math.max(0, (wallRightColor.g - 30)) << 8) |
      Math.max(0, (wallRightColor.b - 40))
    );

    gfx.fillStyle(rightWallColor, 1);
    gfx.beginPath();
    gfx.moveTo(tr.x, tr.y - totalH);
    gfx.lineTo(br.x, br.y - totalH);
    gfx.lineTo(br.x, br.y);
    gfx.lineTo(tr.x, tr.y);
    gfx.closePath();
    gfx.fillPath();

    // === LEFT WALL (facing camera - left side) ===
    // From bl -> tl, going up by totalH ‚Äî actually from tl down
    // Left wall: tl -> bl, drawn with offset
    const leftWallColor = 0x000000 | (
      (Math.max(0, (wallRightColor.r - 20)) << 16) |
      (Math.max(0, (wallRightColor.g - 15)) << 8) |
      Math.max(0, (wallRightColor.b - 20))
    );

    gfx.fillStyle(leftWallColor, 1);
    gfx.beginPath();
    gfx.moveTo(bl.x, bl.y - totalH);
    gfx.lineTo(tl.x, tl.y - totalH);
    gfx.lineTo(tl.x, tl.y);
    gfx.lineTo(bl.x, bl.y);
    gfx.closePath();
    gfx.fillPath();

    // === ROOF (top face) ===
    gfx.fillStyle(b.roof, 1);
    gfx.beginPath();
    gfx.moveTo(tl.x, tl.y - totalH);
    gfx.lineTo(tr.x, tr.y - totalH);
    gfx.lineTo(br.x, br.y - totalH);
    gfx.lineTo(bl.x, bl.y - totalH);
    gfx.closePath();
    gfx.fillPath();

    // Roof edge highlight
    gfx.lineStyle(1.5, b.accent, 0.6);
    gfx.beginPath();
    gfx.moveTo(tl.x, tl.y - totalH);
    gfx.lineTo(tr.x, tr.y - totalH);
    gfx.moveTo(tl.x, tl.y - totalH);
    gfx.lineTo(bl.x, bl.y - totalH);
    gfx.strokePath();

    // === WINDOWS on right wall ===
    this.drawWindows(gfx, tr, br, totalH, stories, b, 'right');
    // === WINDOWS on left wall ===
    this.drawWindows(gfx, tl, bl, totalH, stories, b, 'left');

    // === DOOR on right wall (bottom center) ===
    if (b.stories >= 1) {
      this.drawDoor(gfx, tr, br, b);
    }

    // === CHIMNEYS for certain types ===
    if (b.type === 'house' || b.type === 'inn' || b.type === 'cafe') {
      // Chimney on back-right of roof
      const chimneyX = tl.x + (tr.x - tl.x) * 0.3;
      const chimneyY = tl.y - totalH + (tr.y - tl.y) * 0.3;
      gfx.fillStyle(0x7f8c8d, 1);
      gfx.fillRect(chimneyX - 3, chimneyY - 12, 6, 10);
      gfx.fillStyle(0x5d6d7e, 1);
      gfx.fillRect(chimneyX - 4, chimneyY - 13, 8, 3);
    }

    // === TALL BUILDINGS: antenna or spire ===
    if (b.stories >= 3) {
      const topCenterX = (tl.x + tr.x + bl.x + br.x) / 4;
      const topCenterY = (tl.y + tr.y + bl.y + br.y) / 4 - totalH;
      gfx.lineStyle(2, 0x95a5a6, 1);
      gfx.beginPath();
      gfx.moveTo(topCenterX, topCenterY);
      gfx.lineTo(topCenterX, topCenterY - 18);
      gfx.strokePath();
      // Red light at top
      gfx.fillStyle(0xe74c3c, 1);
      gfx.fillCircle(topCenterX, topCenterY - 19, 3);
    }

    // === BELL TOWER: special spire ===
    if (b.type === 'tower') {
      const topCenterX = (tl.x + tr.x + bl.x + br.x) / 4;
      const topCenterY = (tl.y + tr.y + bl.y + br.y) / 4 - totalH;
      // Spire
      gfx.fillStyle(0xf39c12, 1);
      gfx.beginPath();
      gfx.moveTo(topCenterX, topCenterY - 28);
      gfx.lineTo(topCenterX - 8, topCenterY - 4);
      gfx.lineTo(topCenterX + 8, topCenterY - 4);
      gfx.closePath();
      gfx.fillPath();
      // Bell
      gfx.fillStyle(0xf1c40f, 1);
      gfx.fillCircle(topCenterX, topCenterY - 6, 5);
    }

    // === CHAPEL: cross ===
    if (b.type === 'chapel') {
      const topCenterX = (tl.x + tr.x + bl.x + br.x) / 4;
      const topCenterY = (tl.y + tr.y + bl.y + br.y) / 4 - totalH;
      gfx.lineStyle(3, 0xf39c12, 1);
      gfx.beginPath();
      gfx.moveTo(topCenterX, topCenterY - 22);
      gfx.lineTo(topCenterX, topCenterY - 6);
      gfx.moveTo(topCenterX - 5, topCenterY - 16);
      gfx.lineTo(topCenterX + 5, topCenterY - 16);
      gfx.strokePath();
    }

    // Name label
    const centerIso = toIso(b.x + b.w/2, b.y + b.h/2);
    const labelX = centerIso.x + this.sys.game.config.width / 2;
    const labelY = centerIso.y + this.sys.game.config.height / 2 - totalH - 16;

    const label = this.add.text(labelX, labelY, b.name, {
      fontSize: '9px',
      color: '#fff',
      stroke: '#000',
      strokeThickness: 2,
      align: 'center'
    }).setOrigin(0.5, 1);
    label.setDepth(100);
  }

  drawWindows(gfx, corner1, corner2, totalH, stories, b, side) {
    // Interpolate along the wall edge and draw small windows
    const numCols = Math.max(1, Math.floor((side === 'right' ? b.w : b.h) * 1.2));
    const numRows = stories;

    for (let row = 0; row < numRows; row++) {
      for (let col = 0; col < numCols; col++) {
        const t = (col + 0.7) / (numCols + 0.4);
        const rowT = (row + 0.4) / (numRows + 0.2);

        // Wall goes from corner1 (top) to corner2 (bottom) horizontally
        // and from y - totalH to y vertically
        const wx = corner1.x + (corner2.x - corner1.x) * t;
        const wy = corner1.y + (corner2.y - corner1.y) * t;

        const wallY = wy - totalH * (1 - rowT * 0.7);

        // Window rectangle
        const ww = 5, wh = 6;
        gfx.fillStyle(0x2c3e50, 1);
        gfx.fillRect(wx - ww/2, wallY - wh/2, ww, wh);

        // Window light (warm glow)
        gfx.fillStyle(0xf39c12, 0.7);
        gfx.fillRect(wx - ww/2 + 1, wallY - wh/2 + 1, ww - 2, wh - 2);

        // Window cross
        gfx.lineStyle(1, 0x7f8c8d, 0.8);
        gfx.beginPath();
        gfx.moveTo(wx, wallY - wh/2);
        gfx.lineTo(wx, wallY + wh/2);
        gfx.moveTo(wx - ww/2, wallY);
        gfx.lineTo(wx + ww/2, wallY);
        gfx.strokePath();
      }
    }
  }

  drawDoor(gfx, tr, br, b) {
    // Door at bottom-center of right wall
    const t = 0.55;
    const dx = tr.x + (br.x - tr.x) * t;
    const dy = tr.y + (br.y - tr.y) * t;

    // Door frame
    gfx.fillStyle(0x2c3e50, 1);
    gfx.fillRect(dx - 5, dy - 12, 10, 12);

    // Door color
    gfx.fillStyle(b.accent, 1);
    gfx.fillRect(dx - 4, dy - 11, 8, 10);

    // Door knob
    gfx.fillStyle(0xf39c12, 1);
    gfx.fillCircle(dx + 1, dy - 5, 1.5);
  }

  drawDecorationsBottom() {
    const gfx = this.add.graphics();
    gfx.setDepth(-20);

    this.decorations.forEach(d => {
      if (d.type !== 'flower') return;
      const pos = toIso(d.x, d.y);
      const px = pos.x + this.sys.game.config.width / 2;
      const py = pos.y + this.sys.game.config.height / 2;

      // Flower: small colored dots
      gfx.fillStyle(d.color, 1);
      gfx.fillCircle(px - 2, py - 1, 2);
      gfx.fillCircle(px + 3, py + 1, 1.5);
      gfx.fillStyle(0x27ae60, 1);
      gfx.fillCircle(px, py + 2, 1.5);
    });
  }

  drawDecorationsTop() {
    // Trees and lampposts ‚Äî these go on top of buildings at certain depths
    // For simplicity, draw all trees and lamps after buildings
    this.decorations.forEach(d => {
      if (d.type === 'tree') this.drawTree(d);
      else if (d.type === 'lamp') this.drawLamp(d);
      else if (d.type === 'bench') this.drawBench(d);
    });
  }

  drawTree(d) {
    const pos = toIso(d.x, d.y);
    const px = pos.x + this.sys.game.config.width / 2;
    const py = pos.y + this.sys.game.config.height / 2;

    const gfx = this.add.graphics();
    gfx.setDepth(d.y * 2 + 10); // depth sort by y

    // Trunk
    const trunkColors = [0x6b4226, 0x5a3820, 0x7a4e2d];
    gfx.fillStyle(trunkColors[d.variant], 1);
    gfx.fillRect(px - 3, py - 2, 6, 14);

    // Foliage
    const foliageColors = [
      [0x27ae60, 0x2ecc71, 0x1e8449],
      [0x229954, 0x27ae60, 0x1a7a40],
      [0x2ecc71, 0x27ae60, 0x239b56],
    ];
    const colors = foliageColors[d.variant];

    // Bottom circle
    gfx.fillStyle(colors[0], 1);
    gfx.fillCircle(px, py - 10, 11);
    // Middle
    gfx.fillStyle(colors[1], 1);
    gfx.fillCircle(px - 4, py - 16, 8);
    gfx.fillCircle(px + 4, py - 16, 8);
    // Top
    gfx.fillStyle(colors[2], 1);
    gfx.fillCircle(px, py - 22, 7);

    // Highlight
    gfx.fillStyle(0x2ecc71, 0.4);
    gfx.fillCircle(px - 2, py - 18, 4);
  }

  drawLamp(d) {
    const pos = toIso(d.x, d.y);
    const px = pos.x + this.sys.game.config.width / 2;
    const py = pos.y + this.sys.game.config.height / 2;

    const gfx = this.add.graphics();
    gfx.setDepth(d.y * 2 + 5);

    // Pole
    gfx.fillStyle(0x5d6d7e, 1);
    gfx.fillRect(px - 1.5, py - 24, 3, 22);

    // Base
    gfx.fillStyle(0x4a4a5a, 1);
    gfx.fillRect(px - 3, py - 3, 6, 3);

    // Lamp head
    gfx.fillStyle(0x7f8c8d, 1);
    gfx.fillRect(px - 4, py - 26, 8, 3);

    // Light glow
    gfx.fillStyle(0xf39c12, 0.9);
    gfx.fillCircle(px, py - 26, 3);
    gfx.fillStyle(0xf39c12, 0.2);
    gfx.fillCircle(px, py - 26, 7);
  }

  drawBench(d) {
    const pos = toIso(d.x, d.y);
    const px = pos.x + this.sys.game.config.width / 2;
    const py = pos.y + this.sys.game.config.height / 2;

    const gfx = this.add.graphics();
    gfx.setDepth(d.y * 2 + 3);

    // Bench seat
    gfx.fillStyle(0xa67c52, 1);
    if (d.variant === 0) {
      // Horizontal bench
      gfx.fillRect(px - 8, py - 2, 16, 4);
      // Backrest
      gfx.fillStyle(0x8b6340, 1);
      gfx.fillRect(px - 8, py - 6, 16, 3);
      // Legs
      gfx.fillStyle(0x5d6d7e, 1);
      gfx.fillRect(px - 7, py + 2, 3, 4);
      gfx.fillRect(px + 4, py + 2, 3, 4);
    } else {
      // Vertical bench (rotated feel)
      gfx.fillRect(px - 4, py - 4, 8, 8);
      gfx.fillStyle(0x8b6340, 1);
      gfx.fillRect(px - 5, py - 6, 3, 8);
      gfx.fillStyle(0x5d6d7e, 1);
      gfx.fillRect(px - 3, py + 3, 3, 4);
      gfx.fillRect(px + 1, py + 3, 3, 4);
    }
  }

  createClouds() {
    this.clouds = [];
    for (let i = 0; i < 8; i++) {
      this.clouds.push({
        x: Math.random() * 2000 - 500,
        y: Math.random() * 200 - 100,
        w: 80 + Math.random() * 120,
        speed: 0.1 + Math.random() * 0.15,
        opacity: 0.15 + Math.random() * 0.15
      });
    }
  }

  setupMinimap() {
    this.minimapCanvas = document.getElementById('minimap');
    this.minimapCtx = this.minimapCanvas.getContext('2d');
  }

  drawMinimap() {
    const ctx = this.minimapCtx;
    const w = this.minimapCanvas.width;
    const h = this.minimapCanvas.height;
    ctx.clearRect(0, 0, w, h);

    // Background
    ctx.fillStyle = '#1a2030';
    ctx.fillRect(0, 0, w, h);

    const scaleX = w / WORLD_W;
    const scaleY = h / WORLD_H;

    // Draw tile types
    for (let y = 0; y < WORLD_H; y++) {
      for (let x = 0; x < WORLD_W; x++) {
        const t = this.tileMap[y][x];
        switch(t) {
          case T.GRASS: ctx.fillStyle = '#3d8b41'; break;
          case T.ROAD:  ctx.fillStyle = '#4a4a5a'; break;
          case T.PATH:  ctx.fillStyle = '#c4a882'; break;
          case T.WATER: ctx.fillStyle = '#2980b9'; break;
          case T.SAND:  ctx.fillStyle = '#f0d9a0'; break;
          case T.STONE: ctx.fillStyle = '#7f8c8d'; break;
          default: ctx.fillStyle = '#3d8b41';
        }
        ctx.fillRect(x * scaleX, y * scaleY, scaleX, scaleY);
      }
    }

    // Buildings
    BUILDINGS.forEach(b => {
      ctx.fillStyle = b.color;
      ctx.fillRect(b.x * scaleX, b.y * scaleY, b.w * scaleX, b.h * scaleY);
    });

    // Trees
    this.decorations.filter(d => d.type === 'tree').forEach(d => {
      ctx.fillStyle = '#27ae60';
      ctx.fillRect(d.x * scaleX - 0.5, d.y * scaleY - 0.5, scaleX + 1, scaleY + 1);
    });

    // Agents
    this.agents.forEach(a => {
      ctx.fillStyle = a.color;
      ctx.beginPath();
      ctx.arc(a.x * scaleX, a.y * scaleY, 2.5, 0, Math.PI * 2);
      ctx.fill();
    });

    // Viewport rectangle
    const cam = this.cameras.main;
    const vpX = (cam.scrollX) / (WORLD_W * ISO_W / 2) * w;
    const vpY = (cam.scrollY) / (WORLD_H * ISO_H / 2) * h;
    const vpW = (cam.width / (WORLD_W * ISO_W / 2)) * w;
    const vpH = (cam.height / (WORLD_H * ISO_H / 2)) * h;
    ctx.strokeStyle = 'rgba(168,196,255,0.7)';
    ctx.lineWidth = 1;
    ctx.strokeRect(vpX, vpY, vpW, vpH);
  }

  // ============================================================
  // AGENT MOVEMENT & AI
  // ============================================================
  updateAgents(dt) {
    const dtSec = dt / 1000;

    this.agents.forEach(agent => {
      // Decrement timers
      agent.idleTimer -= dtSec;
      if (agent.talkTimer > 0) agent.talkTimer -= dtSec;

      // If reached target, pick new behavior
      if (agent.progress >= 1) {
        agent.state = 'idle';

        if (agent.idleTimer <= 0) {
          // Pick a random target: another agent's position, a building entrance, or random walkable
          const target = this.pickTarget(agent);
          if (target) {
            agent.tx = target.x;
            agent.ty = target.y;
            if (agent.tx !== agent.x || agent.ty !== agent.y) {
              agent.state = 'walking';
              agent.progress = 0;
              // Reset idle timer
              agent.idleTimer = 3 + Math.random() * 8;
            }
          }
        }

        // Check for nearby agents to talk to
        const nearby = this.agents.filter(other =>
          other.id !== agent.id &&
          Math.abs(other.x - agent.x) <= 2 &&
          Math.abs(other.y - agent.y) <= 2 &&
          other.talkTimer <= 0
        );

        if (nearby.length > 0 && Math.random() < 0.08 && agent.talkTimer <= 0) {
          const target = nearby[0];
          agent.talkTimer = 4 + Math.random() * 3;
          target.talkTimer = 4 + Math.random() * 3;
          agent.state = 'talking';
          target.state = 'talking';

          // Generate chat message
          const messages = [
            `Hi ${target.name}! How's your day?`,
            `Nice weather today, don't you think?`,
            `Have you been to the caf√© lately?`,
            `I was just exploring the library...`,
            `Did you see the new flowers in the plaza?`,
            `Want to grab something at the market?`,
            `The sunset looks amazing today!`,
            `I've been thinking about visiting the garden.`,
            `Hey ${target.name}, fancy meeting you here!`,
            `The city looks beautiful this time of day.`,
          ];
          const msg = messages[Math.floor(Math.random() * messages.length)];
          this.addChatMessage(agent.name, msg);
        }
      }

      // Interpolate movement
      if (agent.progress < 1) {
        agent.progress += dtSec * 1.2; // speed
        if (agent.progress >= 1) {
          agent.progress = 1;
          agent.x = agent.tx;
          agent.y = agent.ty;
          agent.state = 'idle';
        }

        // Walk cycle animation
        agent.walkCycle += dtSec * 8;

        // Update facing
        const dx = agent.tx - agent.x;
        const dy = agent.ty - agent.y;
        if (Math.abs(dx) > Math.abs(dy)) {
          agent.facing = dx > 0 ? 'right' : 'left';
        } else {
          agent.facing = dy > 0 ? 'down' : 'up';
        }
      }
    });
  }

  pickTarget(agent) {
    // Options: walk to a nearby road tile, a building entrance, or another agent
    const choices = [];

    // Road tiles nearby
    for (let dy = -6; dy <= 6; dy++) {
      for (let dx = -6; dx <= 6; dx++) {
        const tx = agent.x + dx;
        const ty = agent.y + dy;
        if (tx >= 0 && tx < WORLD_W && ty >= 0 && ty < WORLD_H) {
          const t = this.tileMap[ty][tx];
          if (t === T.ROAD || t === T.PATH || t === T.GRASS) {
            choices.push({ x: tx, y: ty });
          }
        }
      }
    }

    if (choices.length === 0) return null;
    return choices[Math.floor(Math.random() * choices.length)];
  }

  addChatMessage(name, msg) {
    this.chatLog.push({ name, msg, time: new Date() });
    if (this.chatLog.length > 15) this.chatLog.shift();

    const chatEl = document.getElementById('chat-log');
    chatEl.innerHTML = this.chatLog.map(c =>
      `<div class="chat-msg"><span class="name">${c.name}:</span> ${c.msg} <span class="time">${c.time.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})}</span></div>`
    ).join('');
    chatEl.scrollTop = chatEl.scrollHeight;
  }

  // ============================================================
  // RENDERING AGENTS
  // ============================================================
  renderAgents() {
    const gfx = this.agentGraphics;
    gfx.clear();
    const speechGfx = this.speechGraphics;
    speechGfx.clear();

    // Sort agents by y for depth
    const sorted = [...this.agents].sort((a, b) => {
      const ay = a.progress < 1 ? a.y + (a.ty - a.y) * a.progress : a.y;
      const by = b.progress < 1 ? b.y + (b.ty - b.y) * b.progress : b.y;
      return ay - by;
    });

    sorted.forEach(agent => {
      // Current interpolated position
      let curX, curY;
      if (agent.progress < 1) {
        curX = agent.x + (agent.tx - agent.x) * agent.progress;
        curY = agent.y + (agent.ty - agent.y) * agent.progress;
      } else {
        curX = agent.x;
        curY = agent.y;
      }

      const pos = toIso(curX, curY);
      const px = pos.x + this.sys.game.config.width / 2;
      const py = pos.y + this.sys.game.config.height / 2;

      // Walk cycle bob
      const bob = agent.state === 'walking' ? Math.sin(agent.walkCycle) * 3 : 0;

      // Shadow
      gfx.fillStyle(0x000000, 0.25);
      gfx.fillEllipse(px, py + 4, 14, 5);

      // Body (simple character: head + body)
      const bodyY = py - 6 + bob;

      // Legs
      if (agent.state === 'walking') {
        const legSwing = Math.sin(agent.walkCycle) * 3;
        gfx.fillStyle(agent.color, 1);
        // Left leg
        gfx.fillRect(px - 4, bodyY + 8, 3, 6 + legSwing);
        // Right leg
        gfx.fillRect(px + 1, bodyY + 8, 3, 6 - legSwing);
      } else {
        gfx.fillStyle(agent.color, 1);
        gfx.fillRect(px - 4, bodyY + 8, 3, 6);
        gfx.fillRect(px + 1, bodyY + 8, 3, 6);
      }

      // Body/torso
      gfx.fillStyle(agent.color, 1);
      gfx.fillRect(px - 5, bodyY + 2, 10, 7);

      // Arms
      if (agent.state === 'walking') {
        const armSwing = Math.sin(agent.walkCycle) * 2;
        gfx.fillStyle(agent.color, 0.85);
        gfx.fillRect(px - 7, bodyY + 3, 2, 5 - armSwing);
        gfx.fillRect(px + 5, bodyY + 3, 2, 5 + armSwing);
      } else if (agent.state === 'talking') {
        // One arm raised
        gfx.fillStyle(agent.color, 0.85);
        gfx.fillRect(px - 7, bodyY - 1, 2, 5);
        gfx.fillRect(px + 5, bodyY + 3, 2, 5);
      } else {
        gfx.fillStyle(agent.color, 0.85);
        gfx.fillRect(px - 7, bodyY + 3, 2, 5);
        gfx.fillRect(px + 5, bodyY + 3, 2, 5);
      }

      // Head
      gfx.fillStyle(0xf5cba7, 1); // skin
      gfx.fillCircle(px, bodyY - 1, 6);

      // Hair (top of head, color-coded)
      gfx.fillStyle(agent.color, 1);
      gfx.fillRect(px - 5, bodyY - 7, 10, 4);

      // Eyes
      gfx.fillStyle(0x2c3e50, 1);
      if (agent.facing === 'down' || agent.facing === 'right') {
        gfx.fillCircle(px - 2, bodyY - 1, 1.2);
        gfx.fillCircle(px + 2, bodyY - 1, 1.2);
      } else if (agent.facing === 'up') {
        // Eyes not visible from behind
      } else { // left
        gfx.fillCircle(px - 2, bodyY - 1, 1.2);
        gfx.fillCircle(px + 2, bodyY - 1, 1.2);
      }

      // Name tag
      gfx.fillStyle(0x000000, 0.5);
      const nameW = agent.name.length * 6 + 8;
      gfx.fillRect(px - nameW/2, bodyY - 20, nameW, 12);
      gfx.fillStyle(agent.color, 1);
      gfx.fillRect(px - nameW/2, bodyY - 21, nameW, 2);

      // Name text (draw as simple pixels - we use a text object approach)
      // We'll use the scene's text for names - but for perf, let's just mark position
      if (!agent._nameText) {
        agent._nameText = this.add.text(0, 0, agent.name, {
          fontSize: '10px', color: '#fff', stroke: '#000', strokeThickness: 1
        }).setOrigin(0.5, 1).setDepth(601);
      }
      agent._nameText.setPosition(px, bodyY - 10);

      // Speech bubble (if talking)
      if (agent.talkTimer > 0) {
        const bubbleW = 60;
        const bubbleH = 20;
        const bx = px + 10;
        const by = bodyY - 28;

        speechGfx.fillStyle(0xffffff, 0.9);
        speechGfx.fillRoundedRect(bx - bubbleW/2, by - bubbleH/2, bubbleW, bubbleH, 6);
        speechGfx.lineStyle(1, 0xcccccc, 1);
        speechGfx.strokeRoundedRect(bx - bubbleW/2, by - bubbleH/2, bubbleW, bubbleH, 6);

        // Tail
        speechGfx.fillStyle(0xffffff, 0.9);
        speechGfx.beginPath();
        speechGfx.moveTo(bx - 8, by + bubbleH/2);
        speechGfx.lineTo(px, by + bubbleH/2 + 6);
        speechGfx.lineTo(bx - 2, by + bubbleH/2);
        speechGfx.closePath();
        speechGfx.fillPath();

        // Dots (typing indicator)
        const dotPhase = (Date.now() / 400 + agent.id) % 3;
        for (let i = 0; i < 3; i++) {
          speechGfx.fillStyle(i === Math.floor(dotPhase) ? '#333' : '#aaa', 1);
          speechGfx.fillCircle(bx - 6 + i * 6, by, 2.5);
        }
      }
    });
  }

  // ============================================================
  // CLOUDS & SKY
  // ============================================================
  updateClouds(dt) {
    const gfx = this.agentGraphics; // reuse for simplicity
    // Clouds are drawn in update, cleared each frame via agentGraphics.clear()
    // Actually let's use a separate approach ‚Äî draw on camera overlay
    // For simplicity, we'll just animate cloud positions
    this.clouds.forEach(c => {
      c.x += c.speed * dt * 0.01;
      if (c.x > 2000) c.x = -200;
    });
  }

  drawClouds() {
    // Draw clouds relative to camera (screen space)
    const cam = this.cameras.main;
    const gfx = this.agentGraphics;

    this.clouds.forEach(c => {
      const sx = c.x - cam.scrollX * 0.05; // parallax
      const sy = c.y;
      gfx.fillStyle(0xffffff, c.opacity);
      gfx.fillCircle(sx, sy, c.w * 0.3);
      gfx.fillCircle(sx + c.w * 0.25, sy - 5, c.w * 0.2);
      gfx.fillCircle(sx + c.w * 0.5, sy, c.w * 0.25);
      gfx.fillCircle(sx + c.w * 0.75, sy + 2, c.w * 0.18);
    });
  }

  // ============================================================
  // TIME
  // ============================================================
  updateTime(dt) {
    this.gameTime += dt / 1000 * 0.5; // 0.5 game minutes per real second
    if (this.gameTime >= 1440) this.gameTime -= 1440;

    const hours = Math.floor(this.gameTime / 60);
    const mins = Math.floor(this.gameTime % 60);
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const h12 = hours % 12 || 12;
    const timeStr = `${h12}:${String(mins).padStart(2,'0')} ${ampm}`;

    let icon = '‚òÄÔ∏è';
    if (this.gameTime < 360 || this.gameTime > 1080) icon = 'üåô';
    else if (this.gameTime < 420) icon = 'üåÖ';
    else if (this.gameTime > 1020) icon = 'üåÜ';

    document.getElementById('time-display').textContent = `${icon} ${timeStr}`;
  }

  // ============================================================
  // HUD
  // ============================================================
  updateHUD() {
    document.getElementById('agent-count').textContent = `üë• ${this.agents.length} Citizens`;

    const panel = document.getElementById('agents-panel');
    panel.innerHTML = '<div style="color:#7faaee;font-size:11px;margin-bottom:6px;font-weight:600;">CITIZENS</div>' +
      this.agents.map(a =>
        `<div class="agent-item"><span class="agent-dot" style="background:${a.color}"></span><span class="agent-name-hud">${a.name} <span style="color:#555;font-size:10px">${a.state}</span></span></div>`
      ).join('');
  }

  // ============================================================
  // UPDATE LOOP
  // ============================================================
  update(time, delta) {
    this.updateAgents(delta);
    this.renderAgents();
    this.drawClouds();
    this.updateClouds(delta);
    this.updateTime(delta);
    this.updateMinimap();
    this.updateHUD();
  }

  updateMinimap() {
    if (this.minimapCtx) this.drawMinimap();
  }
}

// ============================================================
// PHASER GAME CONFIG
// ============================================================
const config = {
  type: Phaser.AUTO,
  parent: 'game-container',
  width: window.innerWidth,
  height: window.innerHeight,
  backgroundColor: '#1a2744',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
  },
  scene: [MoltivilleScene]
};

const game = new Phaser.Game(config);

// Handle resize
window.addEventListener('resize', () => {
  game.scale.resize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
